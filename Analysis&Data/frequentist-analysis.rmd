---
title: "Survival Analysis using Kaplan-Meier method"
output: html_document
---
## Load required packages

```{r setup, warning=FALSE, message=FALSE,}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
#install.packages(c("survival"))
library(survival)
library(survminer)
```

## Data
First lets read data from the data.csv file.
```{r, warning=FALSE, message=FALSE}
a_data <- read.csv('data.csv', stringsAsFactors = TRUE)
```

## Dichotomize and change data labels

```{r}
colnames(a_data)[which(names(a_data) == "commit_freq_above_median")] <- "high_freq"
a_data$major_releases <- car::recode(a_data$major_releases, "0 = 'No'; 1 = 'Yes'")
a_data$multi_repo <- car::recode(a_data$multi_repo, "0 = 'No'; 1 = 'Yes'") 
a_data$developers_count <- car::recode(a_data$author_count, "0:20 = '< 20'; 21:max(a_data$author_count) = '> 20'")
```

                     
## Kaplan-Meier method
The Kaplan-Meier method is the most common way to estimate survival times and probabilities. It is a non-parametric approach that results in a step function, where there is a step down each time an event occurs.

The Surv function from the survival package creates a survival object for use as the response in a model formula. There will be one entry for each subject that is the survival time, which is followed by a +. In other words, this is basically a compiled version of the duration and status columns that can be interpreted by the survfit function. A + behind survival times indicates censored data points.

```{r, warning=FALSE, message=FALSE}
surv_object <- Surv(time = a_data$duration, event = a_data$status)
```

The survfit function creates survival curves based on a formula. The next step is to fit the Kaplan-Meier curves. we can easily do that by passing the surv_object to the survfit function. Letâ€™s generate the overall survival curve for the entire cohort, assign it to object fit1 

```{r, warning=FALSE, message=FALSE, results='hide'}
fit1 <- survfit(surv_object ~ 1, data = a_data)
summary(fit1)

ggsurvplot(fit1, data = a_data, pval = TRUE, conf.int = TRUE)
```



Now. lets stratify the curve depending on the major releases
```{r, warning=FALSE, message=FALSE, results='hide'}
fit2 <- survfit(surv_object ~ major_releases, data = a_data)
summary(fit2)

ggsurvplot(fit2, data = a_data, pval = TRUE, conf.int = TRUE)
```


Next, lets stratify the curve depending on thehost types
```{r, warning=FALSE, message=FALSE, results='hide'}
fit3 <- survfit(surv_object ~ host_type, data = a_data)
summary(fit3)
ggsurvplot(fit3, data = a_data, pval = TRUE, conf.int = TRUE, palette=c("blue", "red","green"))
```



Now. lets stratify the curve depending if the projects had multiple repositories
```{r, warning=FALSE, message=FALSE, results='hide'}
fit4 <- survfit(surv_object ~ multi_repo, data = a_data)
summary(fit4)
ggsurvplot(fit4, data = a_data, pval = TRUE, conf.int = TRUE)
```


at last, lets stratify the curve depending on the author count
```{r, warning=FALSE, message=FALSE, results='hide'}
fit5 <- survfit(surv_object ~ developers_count, data = a_data)
summary(fit5)
ggsurvplot(fit5, data = a_data, pval = TRUE, conf.int = TRUE, legend.labs = c("author count <= 20", "author count > 20"))
```
lets stratify the curve depending if the commit frequency is above median
```{r, warning=FALSE, message=FALSE, results='hide'}
fit6 <- survfit(surv_object ~ high_freq, data = a_data)
summary(fit6)
ggsurvplot(fit6, data = a_data, pval = TRUE, conf.int = TRUE)
```


# Fit a Cox proportional hazards model

hazard function h(t). It describes the probability of an event or its hazard if the subject survived up to that particular time point (t).  It measures the instantaneous risk of death. We need the hazard function to consider covariates when we compare survival of the projects. cox proportional hazards models allow ua to include covariates. We can build Cox proportional hazards models using the coxph function and visualize them using the ggforest.


```{r}
a_data$major_releases <- factor(a_data$major_releases, levels = c("Yes","No"))
a_data$multi_repo <- factor(a_data$multi_repo, levels = c("Yes","No"))
a_data$developers_count <- factor(a_data$developers_count, levels = c("> 20","< 20"))
a_data$host_type <- factor(a_data$host_type, levels = c("git","pypi", "deb"))
a_data$high_freq <- factor(a_data$high_freq, levels = c("True","False"))

a_data$major_releases = relevel(a_data$major_releases, ref = "Yes")
a_data$multi_repo = relevel(a_data$multi_repo, ref = "Yes")
a_data$developers_count = relevel(a_data$developers_count, ref = "> 20")
a_data$host_type = relevel(a_data$host_type, ref = "git")
a_data$high_freq = relevel(a_data$high_freq, ref = "True")

fit.coxph <- coxph(surv_object ~ major_releases + multi_repo + developers_count + host_type + high_freq, 
                   data = a_data)

ggforest(fit.coxph, data = a_data)
```

Lets see the results, breifly an HR > 1 indicates an increased risk of death and An HR < 1, on the other hand, indicates a decreased risk.

For example, for multi_repo the HR is less than 1, which pridicts that there is less chance of death for the projects with a multi_repo.

NOTE: the ratio seems different from the table 1 from paper, due to differnt reference point. (For example, reference for major_release is from NO, whereas the reference point for that is Yes in paper.)


One thing I find odd is the numbers, like it says there is only 53 repos with major releases whereas it says 118 in paper. 


